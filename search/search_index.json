{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the Librarian Documentation This is the documentation for Nautilus Librarian . A Python Console application to handle media libraries with Git and Dvc. GitHub page: Nautilus Librarian .","title":"Home"},{"location":"#welcome-to-the-librarian-documentation","text":"This is the documentation for Nautilus Librarian . A Python Console application to handle media libraries with Git and Dvc. GitHub page: Nautilus Librarian .","title":"Welcome to the Librarian Documentation"},{"location":"commands/","text":"Commands The Nautilus Librarian console commands. Gold Images Processing Gold images are a type of image in terms of its purpose, defined on the Nautilus Filename Specification . It is a command to handle Gold image changes in an image dataset (we call it \"Library\"). Description This command allows you to process all the changes in a library repository affecting Gold images. Sample usage: nautilus-librarian gold-images-processing \\ --previous-ref PREVIOUS_REF \\ --current-ref CURRENT_REF Where PREVIOUS_REF and CURRENT_REF ar the git first and last commit references defining the list of commits you want to process. If you handle a dataset of images following the Nautilus Filename Specification , there is a special type of image called \"Gold\" image. That is the first artifact after the acquired media, for example via scanning. Chinese Ideographs is a sample library which follows the Nautilus Filename Specification . It contains some Chinese drawings related to Chinese ideographs. In the data folder you can see all the images: data \u251c\u2500\u2500 000000 \u2502 \u251c\u2500\u2500 32 \u2502 \u2502 \u251c\u2500\u2500 000000-32.600.2.tif \u2502 \u2502 \u2514\u2500\u2500 000000-32.600.2.tif.dvc \u2502 \u2514\u2500\u2500 52 \u2502 \u251c\u2500\u2500 000000-52.600.2.tif \u2502 \u2514\u2500\u2500 000000-52.600.2.tif.dvc ... \u251c\u2500\u2500 000007 \u2502 \u251c\u2500\u2500 32 \u2502 \u2502 \u251c\u2500\u2500 000007-32.600.2.tif \u2502 \u2502 \u2514\u2500\u2500 000007-32.600.2.tif.dvc \u2502 \u2514\u2500\u2500 52 \u2514\u2500\u2500 000008 \u251c\u2500\u2500 32 \u2502 \u251c\u2500\u2500 000008-32.600.2.tif \u2502 \u2514\u2500\u2500 000008-32.600.2.tif.dvc \u2514\u2500\u2500 52 27 directories, 32 files In fact, it does not contain the image itself but the \"pointer\" to the file in the remote DVC storage ( .dvc extensions). DVC is a wrapper on top of Git to version and store binary files. It is an alternative to Git LFS . You can get ( pull ) the real images from the remote DVC storage into your local file system and they are ignored in the Git repository. DVC has a command similar to git diff called dvd diff which give you a list of the changes between two commits. For example, if you clone that repo: git clone https://github.com/Nautilus-Cyberneering/chinese-ideographs cd chinese-ideographs and you run this command: dvc diff --json 420ea8d 6e9878f You will obtain this json object (it's has been truncated here): { \"added\": [], \"deleted\": [ { \"path\": \"data/000000/32/000000-32.600.2.tif\" }, { \"path\": \"data/000008/32/000008-32.600.2.tif\" } ], \"modified\": [ { \"path\": \"data/000001/32/000001-32.600.2.tif\" } ], \"renamed\": [] } This means that some images were deleted and one image was modified. The gold-images-processing command helps you to handle all changes related to Gold images. Gold images are identified by their purpose code 32 . We know that the modified image is a Gold image because the second code in the name is 32 , following the art work ID: 000001-32.600.2.tif . The main goal for this command is to generate Base images automatically. When you add a new Gold image to a library that image is usually too big, and very often you do not need a very high resolution image. Base images are a second type of image that have a lower resolution and can be used for a lot of use cases. The gold-images-processing command automatically generates and keep synced the set of Base images. The gold-images-processing command also helps to keep the library clean and tidy. This is the list of all tasks. Get new or modified Gold images using dvc diff command. Pull images that are going to be processed from DVC remote storage. Validate filenames. Make sure the filename follows the Nautilus Filename Specification . Validate filepaths. Make sure the file is in the right folder. Validate image size. Generate Base image from Gold (change size and ICC profile ). Auto-commit new or changed Base images. The way you usually use this command is by invoking it on a GitHub (or other CI/CD tool) workflow. You can see an example here . Example of invoking the command in a GitHub workflow: - name: Run librarian gold image processing command run: | nautilus-librarian gold-images-processing --previous-ref ${{ env.PREVIOUS_REF }} --current-ref ${{ env.CURRENT_REF }} env: AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }} AZURE_STORAGE_SAS_TOKEN: ${{ secrets.AZURE_STORAGE_SAS_TOKEN }} Arguments Name Description Env Var previous_ref The a_rev in the dvd diff command. See: dvc diff --help . NL_PREVIOUS_REF current_ref The b_rev in the dvd diff command. See: dvc diff --help . NL_CURRENT_REF The previous_ref and current_ref are the positional arguments passed to the dvc diff command: a_rev Old Git commit to compare (defaults to HEAD) b_rev New Git commit to compare (defaults to the current workspace) Options Name Optional Description Default Env Var git_user_name yes Committer name for automatically generated git commits Git global config NL_GIT_USER_NAME git_user_email yes Committer email for automatically generated git commits Git global config NL_GIT_USER_EMAIL git_user_signingkey yes GPG signing key ID to sign commits Git global config NL_GIT_USER_SIGNINGKEY git_repo_dir yes The directory where the Git repository is located Current working dir NL_GIT_REPO_DIR min_image_size yes Minimum Gold image size in pixels for width and height 256 NL_MIN_IMAGE_SIZE max_image_size yes Maximum Gold image size in pixels for width and height 16384 NL_MAX_IMAGE_SIZE base_image_size yes Size for the longer dimension of the Base image 512 NL_BASE_IMAGE_SIZE dvc_diff yes Alternative diff to overwrite previous_ref and current_ref arguments NL_DVC_DIFF dvc_remote yes The name of the remote DVC storage in the .dvc\\config file. See dvc remote command . None NL_DVC_REMOTE gnupghome yes GPG env var to overwrite default --homedir . More info . ~/.gnupg GNUPGHOME GPG is used to sign commits. Git relays on GPG to sign commits. You have to setup your GPG configuration in order to sign commits. Right now signing commits is mandatory but we plan to make it optional . Default Git configuration for commits is also obtained from Git global configuration. We are also planning to change that and let the user preset that configuration before calling this command. Extra environment variables Name Optional Description AZURE_STORAGE_ACCOUNT no Your Azure Storage Account AZURE_STORAGE_SAS_TOKEN no Your SAS token You can use environment variables instead of arguments and options, but some env vars are exclusively env vars. Some of them, like AZURE_STORAGE_ACCOUNT and AZURE_STORAGE_SAS_TOKEN , are used by DVC to access the remote storage. You can find instructions about how to setup a storage for DVC on the DVC documentation . There is also a specific tutorial for adding remote Azure Storage for DVC .","title":"Commands"},{"location":"commands/#commands","text":"The Nautilus Librarian console commands.","title":"Commands"},{"location":"commands/#gold-images-processing","text":"Gold images are a type of image in terms of its purpose, defined on the Nautilus Filename Specification . It is a command to handle Gold image changes in an image dataset (we call it \"Library\").","title":"Gold Images Processing"},{"location":"commands/#description","text":"This command allows you to process all the changes in a library repository affecting Gold images. Sample usage: nautilus-librarian gold-images-processing \\ --previous-ref PREVIOUS_REF \\ --current-ref CURRENT_REF Where PREVIOUS_REF and CURRENT_REF ar the git first and last commit references defining the list of commits you want to process. If you handle a dataset of images following the Nautilus Filename Specification , there is a special type of image called \"Gold\" image. That is the first artifact after the acquired media, for example via scanning. Chinese Ideographs is a sample library which follows the Nautilus Filename Specification . It contains some Chinese drawings related to Chinese ideographs. In the data folder you can see all the images: data \u251c\u2500\u2500 000000 \u2502 \u251c\u2500\u2500 32 \u2502 \u2502 \u251c\u2500\u2500 000000-32.600.2.tif \u2502 \u2502 \u2514\u2500\u2500 000000-32.600.2.tif.dvc \u2502 \u2514\u2500\u2500 52 \u2502 \u251c\u2500\u2500 000000-52.600.2.tif \u2502 \u2514\u2500\u2500 000000-52.600.2.tif.dvc ... \u251c\u2500\u2500 000007 \u2502 \u251c\u2500\u2500 32 \u2502 \u2502 \u251c\u2500\u2500 000007-32.600.2.tif \u2502 \u2502 \u2514\u2500\u2500 000007-32.600.2.tif.dvc \u2502 \u2514\u2500\u2500 52 \u2514\u2500\u2500 000008 \u251c\u2500\u2500 32 \u2502 \u251c\u2500\u2500 000008-32.600.2.tif \u2502 \u2514\u2500\u2500 000008-32.600.2.tif.dvc \u2514\u2500\u2500 52 27 directories, 32 files In fact, it does not contain the image itself but the \"pointer\" to the file in the remote DVC storage ( .dvc extensions). DVC is a wrapper on top of Git to version and store binary files. It is an alternative to Git LFS . You can get ( pull ) the real images from the remote DVC storage into your local file system and they are ignored in the Git repository. DVC has a command similar to git diff called dvd diff which give you a list of the changes between two commits. For example, if you clone that repo: git clone https://github.com/Nautilus-Cyberneering/chinese-ideographs cd chinese-ideographs and you run this command: dvc diff --json 420ea8d 6e9878f You will obtain this json object (it's has been truncated here): { \"added\": [], \"deleted\": [ { \"path\": \"data/000000/32/000000-32.600.2.tif\" }, { \"path\": \"data/000008/32/000008-32.600.2.tif\" } ], \"modified\": [ { \"path\": \"data/000001/32/000001-32.600.2.tif\" } ], \"renamed\": [] } This means that some images were deleted and one image was modified. The gold-images-processing command helps you to handle all changes related to Gold images. Gold images are identified by their purpose code 32 . We know that the modified image is a Gold image because the second code in the name is 32 , following the art work ID: 000001-32.600.2.tif . The main goal for this command is to generate Base images automatically. When you add a new Gold image to a library that image is usually too big, and very often you do not need a very high resolution image. Base images are a second type of image that have a lower resolution and can be used for a lot of use cases. The gold-images-processing command automatically generates and keep synced the set of Base images. The gold-images-processing command also helps to keep the library clean and tidy. This is the list of all tasks. Get new or modified Gold images using dvc diff command. Pull images that are going to be processed from DVC remote storage. Validate filenames. Make sure the filename follows the Nautilus Filename Specification . Validate filepaths. Make sure the file is in the right folder. Validate image size. Generate Base image from Gold (change size and ICC profile ). Auto-commit new or changed Base images. The way you usually use this command is by invoking it on a GitHub (or other CI/CD tool) workflow. You can see an example here . Example of invoking the command in a GitHub workflow: - name: Run librarian gold image processing command run: | nautilus-librarian gold-images-processing --previous-ref ${{ env.PREVIOUS_REF }} --current-ref ${{ env.CURRENT_REF }} env: AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }} AZURE_STORAGE_SAS_TOKEN: ${{ secrets.AZURE_STORAGE_SAS_TOKEN }}","title":"Description"},{"location":"commands/#arguments","text":"Name Description Env Var previous_ref The a_rev in the dvd diff command. See: dvc diff --help . NL_PREVIOUS_REF current_ref The b_rev in the dvd diff command. See: dvc diff --help . NL_CURRENT_REF The previous_ref and current_ref are the positional arguments passed to the dvc diff command: a_rev Old Git commit to compare (defaults to HEAD) b_rev New Git commit to compare (defaults to the current workspace)","title":"Arguments"},{"location":"commands/#options","text":"Name Optional Description Default Env Var git_user_name yes Committer name for automatically generated git commits Git global config NL_GIT_USER_NAME git_user_email yes Committer email for automatically generated git commits Git global config NL_GIT_USER_EMAIL git_user_signingkey yes GPG signing key ID to sign commits Git global config NL_GIT_USER_SIGNINGKEY git_repo_dir yes The directory where the Git repository is located Current working dir NL_GIT_REPO_DIR min_image_size yes Minimum Gold image size in pixels for width and height 256 NL_MIN_IMAGE_SIZE max_image_size yes Maximum Gold image size in pixels for width and height 16384 NL_MAX_IMAGE_SIZE base_image_size yes Size for the longer dimension of the Base image 512 NL_BASE_IMAGE_SIZE dvc_diff yes Alternative diff to overwrite previous_ref and current_ref arguments NL_DVC_DIFF dvc_remote yes The name of the remote DVC storage in the .dvc\\config file. See dvc remote command . None NL_DVC_REMOTE gnupghome yes GPG env var to overwrite default --homedir . More info . ~/.gnupg GNUPGHOME GPG is used to sign commits. Git relays on GPG to sign commits. You have to setup your GPG configuration in order to sign commits. Right now signing commits is mandatory but we plan to make it optional . Default Git configuration for commits is also obtained from Git global configuration. We are also planning to change that and let the user preset that configuration before calling this command.","title":"Options"},{"location":"commands/#extra-environment-variables","text":"Name Optional Description AZURE_STORAGE_ACCOUNT no Your Azure Storage Account AZURE_STORAGE_SAS_TOKEN no Your SAS token You can use environment variables instead of arguments and options, but some env vars are exclusively env vars. Some of them, like AZURE_STORAGE_ACCOUNT and AZURE_STORAGE_SAS_TOKEN , are used by DVC to access the remote storage. You can find instructions about how to setup a storage for DVC on the DVC documentation . There is also a specific tutorial for adding remote Azure Storage for DVC .","title":"Extra environment variables"},{"location":"development/","text":"Development Run With docker: Build: ./bin/docker/build.sh Run pre-built docker image: ./bin/docker/run.sh [OPTIONS] COMMAND [ARGS]... ./bin/docker/run.sh --help Run mounting current repo: ./bin/docker/run-dev.sh [OPTIONS] COMMAND [ARGS]... ./bin/docker/run-dev.sh --help With Poetry: pip install poetry poetry-dynamic-versioning poetry install poetry run nautilus-librarian [OPTIONS] COMMAND [ARGS]... poetry run nautilus-librarian --help NOTE: With Poetry, you have to install the Librarian system dependencies . Build pip install poetry poetry-dynamic-versioning poetry install poetry build You should have the package in the dist folder. You can install the package locally with: pip install --user --force-reinstall dist/nautilus_librarian-0.2.1.post2.dev0+871cb83-py3-none-any.whl Where 0.2.1.post2.dev0+871cb83 is the package version. You can get the package version with: poetry version . Remember to exit from your poetry Python environment. If you open the wheel file (zip) you will find the version in the nautilus_librarian/_version.py file: ... __version__: str = \"0.2.1.post2.dev0+871cb83\" ... Testing With docker: ./bin/docker/test.sh With Poetry: poetry shell pytest or: poetry run pytest --cov Some useful test commands: Run only one test ( -k ) with no capture ( -s ): pytest -s -k \"test_app\" Linting With MegaLinter : Install: npm install mega-linter-runner -g Run with the auto fix: mega-linter-runner --fix Run workflows locally You can use act to run workflows locally. For example: act -W ./.github/workflows/test.yml -j build With that command, you can run the build job in the test.yml workflow. If the workflow requires some environment variables you can add them in a local .secrets file (in the project root dir). In the .secrets.template file you will find an example with the environment variables you need for the test.yml workflow. Running workflows with act can be very tricky. There are some GitHub Actions features that do not work locally even if you use the full act docker image. We recommend to use act if you are testing the integration between the Librarian and a GitHub workflow. If you just want to test a Librarian command with your development version of the Librarian you can run it with Poetry for a different target directory. For example, the poetry run nautilus-librarian gold-images-processing ... generates some auto-commits so you can not run it just like that because it will create commits on your development branch. In order to test the command you can create a temporary dir and pass that dir as an argument to the Librarian: First, setup for your test directory: cd /tmp git clone git@github.com:Nautilus-Cyberneering/dvc-test-repo.git cd dvc-test-repo/ ... You can do whatever you need to create the initial state you want to test. And then you can run the command with: poetry run nautilus-librarian gold-images-processing --git-repo-dir=/tmp/dvc-test-repo --gnupghome=~/.gnupg --previous-ref=61f51f1 --current-ref=145851a ... You can also overwrite other directories like the GPG home dir ( ~/.gnupg ), a DVC local remote storage , etcetera. Releases We use Semantic Versioning 2.0.0 . To publish a new release, you only new to create the tag (for example, v1.3.0 ) and push it to GitHub . git tag v1.3.0 git push origin v1.3.0 Commits We are using Conventional Commits . Security The application uses a lot of console commands. Commands that use arguments taken from user input could be a potential security risk. Please review the rules to avoid command injection before adding a new console command. If you want to know more about command injection please read the links below. The basic rules to follow when you add a new console command are: Always try to use an internal Python API (if it exists) instead of running an OS command. Try to use a high-level wrapper instead of executing a command: gpg_connect_agent(...) , git(...) , dvc(...) , gpg(...) . Do not pass user-controlled input (if possible). If you need it, consider using validation before passing values. If you expect a file path, check if the file exists. If you expect an email, validate the email, etcetera. Do not use \"shell\" if not needed. Consider using execute_console_command instead of execute_shell_command . Do not use \"f-string\" with execute_console_command and execute_shell_command . Consider using placeholders in the command string and passing variables values as keyword arguments. Those functions use the function shlex.quote(..) to scape the values. For example: execute_console_command( \"dvc remote add -d {remote_name} {remote_dir}\", remote_name=remote_name, remote_dir=remote_dir, cwd=self.git_repo_dir, ) instead of: execute_console_command( f\"dvc remote add -d {remote_name} {remote_dir}\", cwd=self.git_repo_dir, ) Links: OS Command Injection in Python Command injection prevention for Python","title":"Development"},{"location":"development/#development","text":"","title":"Development"},{"location":"development/#run","text":"With docker: Build: ./bin/docker/build.sh Run pre-built docker image: ./bin/docker/run.sh [OPTIONS] COMMAND [ARGS]... ./bin/docker/run.sh --help Run mounting current repo: ./bin/docker/run-dev.sh [OPTIONS] COMMAND [ARGS]... ./bin/docker/run-dev.sh --help With Poetry: pip install poetry poetry-dynamic-versioning poetry install poetry run nautilus-librarian [OPTIONS] COMMAND [ARGS]... poetry run nautilus-librarian --help NOTE: With Poetry, you have to install the Librarian system dependencies .","title":"Run"},{"location":"development/#build","text":"pip install poetry poetry-dynamic-versioning poetry install poetry build You should have the package in the dist folder. You can install the package locally with: pip install --user --force-reinstall dist/nautilus_librarian-0.2.1.post2.dev0+871cb83-py3-none-any.whl Where 0.2.1.post2.dev0+871cb83 is the package version. You can get the package version with: poetry version . Remember to exit from your poetry Python environment. If you open the wheel file (zip) you will find the version in the nautilus_librarian/_version.py file: ... __version__: str = \"0.2.1.post2.dev0+871cb83\" ...","title":"Build"},{"location":"development/#testing","text":"With docker: ./bin/docker/test.sh With Poetry: poetry shell pytest or: poetry run pytest --cov Some useful test commands: Run only one test ( -k ) with no capture ( -s ): pytest -s -k \"test_app\"","title":"Testing"},{"location":"development/#linting","text":"With MegaLinter : Install: npm install mega-linter-runner -g Run with the auto fix: mega-linter-runner --fix","title":"Linting"},{"location":"development/#run-workflows-locally","text":"You can use act to run workflows locally. For example: act -W ./.github/workflows/test.yml -j build With that command, you can run the build job in the test.yml workflow. If the workflow requires some environment variables you can add them in a local .secrets file (in the project root dir). In the .secrets.template file you will find an example with the environment variables you need for the test.yml workflow. Running workflows with act can be very tricky. There are some GitHub Actions features that do not work locally even if you use the full act docker image. We recommend to use act if you are testing the integration between the Librarian and a GitHub workflow. If you just want to test a Librarian command with your development version of the Librarian you can run it with Poetry for a different target directory. For example, the poetry run nautilus-librarian gold-images-processing ... generates some auto-commits so you can not run it just like that because it will create commits on your development branch. In order to test the command you can create a temporary dir and pass that dir as an argument to the Librarian: First, setup for your test directory: cd /tmp git clone git@github.com:Nautilus-Cyberneering/dvc-test-repo.git cd dvc-test-repo/ ... You can do whatever you need to create the initial state you want to test. And then you can run the command with: poetry run nautilus-librarian gold-images-processing --git-repo-dir=/tmp/dvc-test-repo --gnupghome=~/.gnupg --previous-ref=61f51f1 --current-ref=145851a ... You can also overwrite other directories like the GPG home dir ( ~/.gnupg ), a DVC local remote storage , etcetera.","title":"Run workflows locally"},{"location":"development/#releases","text":"We use Semantic Versioning 2.0.0 . To publish a new release, you only new to create the tag (for example, v1.3.0 ) and push it to GitHub . git tag v1.3.0 git push origin v1.3.0","title":"Releases"},{"location":"development/#commits","text":"We are using Conventional Commits .","title":"Commits"},{"location":"development/#security","text":"The application uses a lot of console commands. Commands that use arguments taken from user input could be a potential security risk. Please review the rules to avoid command injection before adding a new console command. If you want to know more about command injection please read the links below. The basic rules to follow when you add a new console command are: Always try to use an internal Python API (if it exists) instead of running an OS command. Try to use a high-level wrapper instead of executing a command: gpg_connect_agent(...) , git(...) , dvc(...) , gpg(...) . Do not pass user-controlled input (if possible). If you need it, consider using validation before passing values. If you expect a file path, check if the file exists. If you expect an email, validate the email, etcetera. Do not use \"shell\" if not needed. Consider using execute_console_command instead of execute_shell_command . Do not use \"f-string\" with execute_console_command and execute_shell_command . Consider using placeholders in the command string and passing variables values as keyword arguments. Those functions use the function shlex.quote(..) to scape the values. For example: execute_console_command( \"dvc remote add -d {remote_name} {remote_dir}\", remote_name=remote_name, remote_dir=remote_dir, cwd=self.git_repo_dir, ) instead of: execute_console_command( f\"dvc remote add -d {remote_name} {remote_dir}\", cwd=self.git_repo_dir, ) Links: OS Command Injection in Python Command injection prevention for Python","title":"Security"},{"location":"documentation/","text":"Documentation We are using MkDocs for this documentation site. Commands mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. mkdocs gh-deploy -v --force - Deploy to GitHub Pages . You might see this error when you try to execute those commands: $ mkdocs Command 'mkdocs' not found, but can be installed with: sudo apt install mkdocs You can install it with: poetry install and run it via Poetry: poetry run mkdocs serve poetry run mkdocs ... poetry run mkdocs OPTION Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Documentation"},{"location":"documentation/#documentation","text":"We are using MkDocs for this documentation site.","title":"Documentation"},{"location":"documentation/#commands","text":"mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. mkdocs gh-deploy -v --force - Deploy to GitHub Pages . You might see this error when you try to execute those commands: $ mkdocs Command 'mkdocs' not found, but can be installed with: sudo apt install mkdocs You can install it with: poetry install and run it via Poetry: poetry run mkdocs serve poetry run mkdocs ... poetry run mkdocs OPTION","title":"Commands"},{"location":"documentation/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"glossary/","text":"Glossary Library : it's a Git repository containing a dataset of images. DVC : an Open-source Version Control System for Machine Learning Projects . Gold image: it's a specific purpose image contained in a library. See Nautilus Filename Specification to get the list of types of images.","title":"Glossary"},{"location":"glossary/#glossary","text":"Library : it's a Git repository containing a dataset of images. DVC : an Open-source Version Control System for Machine Learning Projects . Gold image: it's a specific purpose image contained in a library. See Nautilus Filename Specification to get the list of types of images.","title":"Glossary"},{"location":"install/","text":"Install Requirements: Libvips-dev 8.10.5-2 Python 3.9 Install Python Package: pip install nautilus-librarian Install system dependencies (ubuntu): sudo apt-get update sudo apt-get upgrade -y sudo apt-get install -y libvips-dev Example commands: nautilus-librarian [OPTIONS] COMMAND [ARGS]... nautilus-librarian --help nautilus-librarian namecodes --help nautilus-librarian namecodes validate-filename 000000-32.600.2.tif You can also use the docker image from the DockerHub registry: docker run --rm -it nautiluscyberneering/librarian [OPTIONS] COMMAND [ARGS]... docker run --rm -it nautiluscyberneering/librarian --help Or the docker image from the GitHub registry: docker run --rm -it ghcr.io/nautilus-cyberneering/librarian [OPTIONS] COMMAND [ARGS]... docker run --rm -it ghcr.io/nautilus-cyberneering/librarian --help Links DockerHub docker image nautiluscyberneering/librarian GitHub docker image ghcr.io/nautiluscyberneering/librarian","title":"Install"},{"location":"install/#install","text":"Requirements: Libvips-dev 8.10.5-2 Python 3.9 Install Python Package: pip install nautilus-librarian Install system dependencies (ubuntu): sudo apt-get update sudo apt-get upgrade -y sudo apt-get install -y libvips-dev Example commands: nautilus-librarian [OPTIONS] COMMAND [ARGS]... nautilus-librarian --help nautilus-librarian namecodes --help nautilus-librarian namecodes validate-filename 000000-32.600.2.tif You can also use the docker image from the DockerHub registry: docker run --rm -it nautiluscyberneering/librarian [OPTIONS] COMMAND [ARGS]... docker run --rm -it nautiluscyberneering/librarian --help Or the docker image from the GitHub registry: docker run --rm -it ghcr.io/nautilus-cyberneering/librarian [OPTIONS] COMMAND [ARGS]... docker run --rm -it ghcr.io/nautilus-cyberneering/librarian --help","title":"Install"},{"location":"install/#links","text":"DockerHub docker image nautiluscyberneering/librarian GitHub docker image ghcr.io/nautiluscyberneering/librarian","title":"Links"}]}